<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIBES Phenomenological Topology</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-haskell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-kotlin.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scala.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #fafafa;
            color: #333;
            font-family: 'SF Mono', 'Consolas', 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            position: relative;
        }
        
        /* Subtle vignette and film effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at center, transparent 60%, rgba(0, 0, 0, 0.03) 100%),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.005) 2px,
                    rgba(0, 0, 0, 0.005) 4px
                );
            pointer-events: none;
            z-index: 10;
        }
        
        /* Subtle scan-line effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(68, 136, 255, 0.1), transparent);
            animation: scan-line 8s ease-in-out infinite;
            pointer-events: none;
            z-index: 15;
        }
        
        @keyframes scan-line {
            0%, 100% { transform: translateY(0); opacity: 0; }
            50% { transform: translateY(100vh); opacity: 1; }
        }
        
        svg {
            cursor: default;
        }
        
        .surface-path {
            stroke: rgba(0, 0, 0, 0.15);
            stroke-width: 0.5;
            fill-opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        /* Enhanced surface materials */
        .primary-surface {
            filter: url(#noise-texture);
        }
        
        .error-surface {
            stroke: rgba(139, 69, 19, 0.3);
            filter: url(#noise-texture) brightness(0.95);
        }
        
        .resonance-surface {
            filter: url(#noise-texture) url(#shimmer);
            animation: subtle-shimmer 4s ease-in-out infinite;
        }
        
        /* Surface edge highlighting (Fresnel effect) */
        .surface-path:hover {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 1.5;
            filter: brightness(1.1);
        }
        
        /* Shimmer animation for resonance surface */
        @keyframes subtle-shimmer {
            0%, 100% { filter: url(#noise-texture) brightness(1.0); }
            50% { filter: url(#noise-texture) brightness(1.05) saturate(1.1); }
        }
        
        .vertex-point {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .vertex-point:hover {
            r: 6;
            filter: brightness(1.3);
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            max-width: 380px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }
        
        .state-card {
            background: rgba(255, 255, 255, 0.85) !important;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.5) !important;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .state-card:hover {
            transform: translateY(-4px);
            box-shadow: 
                0 12px 48px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.9) !important;
        }
        
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            white-space: pre;
            line-height: 1.4;
            overflow-x: auto;
        }
        
        .code-lang {
            font-size: 10px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            font-size: 13px;
        }
        
        h2 {
            margin-top: 0;
            font-size: 24px;
        }
        
        /* Enhanced typography hierarchy */
        #state-title {
            font-size: 32px !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            font-weight: 700 !important;
        }
        
        #state-coords {
            font-family: 'SF Mono', 'Consolas', 'Courier New', monospace !important;
            font-size: 14px !important;
            color: #555 !important;
        }
        
        .coord-signal { color: #dc2626; font-weight: 600; }
        .coord-deps { color: #7c3aed; font-weight: 600; }
        .coord-error { color: #059669; font-weight: 600; }
        
        #state-description {
            line-height: 1.6 !important;
            font-size: 15px !important;
        }
        
        .axis-rail {
            transition: all 0.2s ease;
        }
        
        .axis-rail:hover {
            filter: brightness(1.2) drop-shadow(0 0 10px rgba(68, 136, 255, 0.5));
        }
        
        .axis-orb {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .axis-orb.at-position {
            r: 14 !important;
            filter: drop-shadow(0 0 15px #4488ff) !important;
        }
        
        /* Enhanced axis visual hierarchy */
        .axis-segment {
            stroke-width: 20;
            opacity: 0.7;
            transition: all 0.2s ease;
        }
        
        .axis-segment:hover {
            opacity: 1;
            filter: drop-shadow(0 0 10px currentColor);
        }
        
        /* Enhanced interaction feedback */
        .axis-group:hover .axis-segment {
            opacity: 0.9;
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .axis-segment-border:hover {
            stroke: rgba(255, 255, 255, 1);
            stroke-width: 2;
        }
        
        .axis-tick {
            stroke: #333;
            stroke-width: 4;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
        }
        
        .axis-segment-border {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-width: 1;
            fill: none;
            pointer-events: none;
        }
        
        .grid-line {
            stroke: rgba(0, 0, 0, 0.08);
            stroke-width: 0.5;
            stroke-dasharray: 2,2;
            opacity: 0.5;
        }
        
        /* Pulsing orb animation */
        @keyframes pulse-glow {
            0%, 100% { 
                filter: drop-shadow(0 0 10px #4488ff); 
                r: 12;
            }
            50% { 
                filter: drop-shadow(0 0 20px #4488ff) drop-shadow(0 0 40px rgba(68, 136, 255, 0.3)); 
                r: 14;
            }
        }
        
        .axis-orb-current {
            animation: pulse-glow 2s ease-in-out infinite;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Micro-animations for state changes */
        .state-card {
            animation: subtle-pulse 3s ease-in-out infinite;
        }
        
        @keyframes subtle-pulse {
            0%, 100% { transform: translateY(-2px) scale(1.0); }
            50% { transform: translateY(-3px) scale(1.001); }
        }
        
        /* Enhanced transitions for all interactive elements */
        .axis-segment, .axis-tick, .projection-line, .intersection-point {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Performance optimizations */
        .surface-path, .cube-edge {
            will-change: transform, opacity;
        }
        
        .axis-label {
            font-size: 16px;
            fill: #333;
            text-anchor: middle;
            font-weight: bold;
        }
        
        /* Enhanced wireframe and projection styling */
        .cube-edge {
            stroke: #666;
            stroke-width: 2;
            stroke-opacity: 0.4;
            stroke-dasharray: 8,4;
        }
        
        .projection-line {
            stroke: #4488ff;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            opacity: 0.6;
        }
        
        .intersection-point {
            fill: #ffffff;
            stroke-width: 3;
            filter: drop-shadow(0 0 15px currentColor);
        }
        
        .emoji-large {
            font-size: 24px;
        }
        
        /* Slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #ddd;
            height: 8px;
            border-radius: 4px;
        }
        
        input[type="range"]::-moz-range-track {
            background: #ddd;
            height: 8px;
            border-radius: 4px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #4488ff;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            margin-top: -6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb {
            background: #4488ff;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            background: #3377ee;
            transform: scale(1.1);
        }
        
        input[type="range"]:hover::-moz-range-thumb {
            background: #3377ee;
            transform: scale(1.1);
        }
        
        /* State constellation mini-map */
        .state-constellation {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            z-index: 100;
        }
        
        .state-constellation::before {
            content: 'STATE MAP';
            position: absolute;
            top: 8px;
            left: 10px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            color: #666;
            font-family: 'SF Mono', monospace;
        }
        
        #constellation-svg {
            margin-top: 15px;
        }
        
        .constellation-trail {
            fill: none;
            stroke: #4488ff;
            stroke-width: 1.5;
            stroke-linecap: round;
            opacity: 0.3;
        }
        
        .constellation-point {
            fill: #4488ff;
            stroke: white;
            stroke-width: 2;
        }
        
        .constellation-current {
            fill: #ffaa00;
            stroke: white;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px #ffaa00);
        }
        
        .constellation-heat {
            fill: #ff6b6b;
            opacity: 0.1;
        }
        
        .preset-btn {
            padding: 12px 16px !important;
            background: rgba(255, 255, 255, 0.9) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
            border-radius: 10px !important;
            cursor: pointer !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
            backdrop-filter: blur(8px) !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05) !important;
        }
        
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.95) !important;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15) !important;
            border-color: rgba(68, 136, 255, 0.3) !important;
        }
        
        .preset-btn:active {
            transform: translateY(0) scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }
        
        .preset-btn.active {
            background: rgba(68, 136, 255, 0.1) !important;
            border-color: #4488ff !important;
            box-shadow: 
                0 4px 12px rgba(68, 136, 255, 0.2),
                inset 0 0 0 2px rgba(68, 136, 255, 0.2) !important;
        }
        
        #selected-indicator {
            pointer-events: none;
            stroke-width: 4;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { r: 12; opacity: 0.8; }
            50% { r: 16; opacity: 1; }
        }
        
        /* Phenomenology section animation */
        #phenomenology-section {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        #phenomenology-section.show {
            display: block !important;
        }
        
        /* Search panel styles */
        .search-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05);
            max-width: 320px;
            transition: all 0.3s ease;
        }
        
        .search-panel.collapsed {
            padding: 12px;
            max-width: 48px;
            overflow: hidden;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'SF Mono', 'Consolas', monospace;
            transition: all 0.2s ease;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #4488ff;
            box-shadow: 0 0 0 3px rgba(68, 136, 255, 0.1);
        }
        
        .filter-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #eee;
        }
        
        .filter-checkbox {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
            cursor: pointer;
        }
        
        .filter-checkbox input {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .filter-checkbox label {
            cursor: pointer;
            user-select: none;
        }
        
        .search-results {
            margin-top: 12px;
            font-size: 12px;
            color: #666;
        }
        
        .vertex-highlight {
            animation: pulse-highlight 2s ease-in-out infinite;
        }
        
        @keyframes pulse-highlight {
            0%, 100% { 
                filter: drop-shadow(0 0 20px #ff0066) brightness(1.2); 
                r: 8;
            }
            50% { 
                filter: drop-shadow(0 0 40px #ff0066) brightness(1.4); 
                r: 10;
            }
        }
        
        .vertex-dimmed {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            body {
                font-size: 14px;
            }
            
            svg {
                width: 100vw !important;
                height: 60vh !important;
            }
            
            .info-panel {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                margin: 10px;
                max-width: none;
            }
            
            .state-description {
                position: relative;
                bottom: auto;
                left: auto;
                right: auto;
                margin: 10px;
                max-width: none;
                max-height: 300px;
            }
            
            .legend {
                position: relative;
                bottom: auto;
                right: auto;
                margin: 10px;
                font-size: 11px;
            }
            
            .slider-controls {
                padding: 15px !important;
            }
            
            .preset-btn {
                font-size: 12px !important;
                padding: 6px 12px !important;
            }
            
            .code-example {
                font-size: 10px !important;
                max-height: 200px;
                overflow-y: auto;
            }
        }
        
        @media (max-width: 480px) {
            /* Disable performance-heavy effects on mobile */
            body::before, body::after {
                display: none;
            }
            
            .surface-path {
                filter: none !important;
                animation: none !important;
            }
            
            .state-card {
                animation: none;
                backdrop-filter: blur(5px);
            }
            
            .axis-orb-current {
                animation: none;
            }
            
            /* Increased touch targets */
            .axis-segment {
                stroke-width: 30 !important;
            }
            
            .preset-btn {
                padding: 16px 20px !important;
                font-size: 16px !important;
            }
            
            /* Higher contrast for outdoor viewing */
            .axis-tick {
                stroke-width: 6 !important;
            }
            
            .cube-edge {
                stroke-opacity: 0.8 !important;
                stroke-width: 3 !important;
            }
            
            /* Simplified typography */
            .info-panel h2 {
                font-size: 20px;
            }
            
            .state-description h3 {
                font-size: 18px;
            }
            
            .emoji-large {
                font-size: 20px;
            }
            
            .legend {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <svg id="visualization" width="1200" height="700"></svg>
    
    <div class="info-panel">
        <h2>VIBES Phenomenological Topology</h2>
        <p>Click any vertex to explore how that state combination feels.</p>
        <div style="margin-top: 15px;">
            <div><strong>Signal Density</strong>: 🔬 → 🔍 → 👓 → 🙈</div>
            <div><strong>Dependencies</strong>: 🎀 → 🪢 → 🧶 → 🌀</div>
            <div><strong>Error Surface</strong>: 💠 → 🧊 → 💧 → 🌊</div>
        </div>
        <p style="margin-top: 15px; font-size: 12px; color: #666;">
            Multiple surfaces show different phenomenological layers.
            Height represents cognitive intensity.
        </p>
    </div>
    
    <div class="state-card" id="state-card" style="position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.95); padding: 24px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 0 0 1px rgba(0, 0, 0, 0.05); max-width: 380px; backdrop-filter: blur(10px);">
        <div style="text-align: center; margin-bottom: 16px;">
            <span id="state-emoji" style="font-size: 64px; filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.1));">🔬🎀💠</span>
        </div>
        <div style="text-align: center;">
            <h3 id="state-title" style="margin: 0 0 4px 0; font-size: 20px; font-weight: 600;">Absolute Transcendence</h3>
            <p id="state-coords" style="margin: 0 0 12px 0; font-size: 13px; color: #666; font-family: 'SF Mono', monospace;">Signal: 3, Dependencies: 3, Error: 3</p>
        </div>
        <p id="state-description" style="margin: 0; font-size: 14px; line-height: 1.5; color: #333;">Peak phenomenological state. Every pattern resonates with crystalline clarity.</p>
        <div id="phenomenology-section" style="margin-top: 12px; display: none;">
            <div style="padding: 12px; background: rgba(68, 136, 255, 0.05); border-radius: 8px; border-left: 3px solid #4488ff;">
                <p id="state-phenomenology" style="margin: 0; font-size: 13px; line-height: 1.6; color: #555; font-style: italic;"></p>
            </div>
        </div>
        <div style="margin-top: 12px;">
            <button id="phenomenology-toggle" onclick="togglePhenomenology()" style="background: none; border: none; color: #4488ff; cursor: pointer; font-size: 13px; padding: 4px 0; text-decoration: underline; text-underline-offset: 2px;">
                Show phenomenology →
            </button>
        </div>
        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #eee;">
            <button onclick="showCodeExample()" style="width: 100%; padding: 8px 16px; background: #4488ff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500;">
                View Code Example →
            </button>
        </div>
    </div>
    
    <div class="search-panel" id="search-panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="margin: 0; font-size: 16px; font-weight: 600;">Search States</h3>
            <button onclick="toggleSearchPanel()" style="background: none; border: none; cursor: pointer; padding: 4px; color: #666;">
                <span id="search-toggle-icon">−</span>
            </button>
        </div>
        <div id="search-content">
            <input type="text" class="search-input" id="search-input" placeholder="Search by title, description, or emoji..." />
            
            <div class="filter-section">
                <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600;">Filter by Type</h4>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-transcendent" checked>
                    <label for="filter-transcendent"><span style="color: #10b981;">●</span> Transcendent (8-9)</label>
                </div>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-good" checked>
                    <label for="filter-good"><span style="color: #84cc16;">●</span> Good (6-7)</label>
                </div>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-functional" checked>
                    <label for="filter-functional"><span style="color: #fbbf24;">●</span> Functional (4-5)</label>
                </div>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-degraded" checked>
                    <label for="filter-degraded"><span style="color: #f59e0b;">●</span> Degraded (2-3)</label>
                </div>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-struggling" checked>
                    <label for="filter-struggling"><span style="color: #ef4444;">●</span> Struggling (1)</label>
                </div>
                <div class="filter-checkbox">
                    <input type="checkbox" id="filter-catastrophic" checked>
                    <label for="filter-catastrophic"><span style="color: #991b1b;">●</span> Catastrophic (0)</label>
                </div>
            </div>
            
            <div class="search-results" id="search-results">
                <span id="search-count">64</span> states shown
            </div>
            
            <button onclick="clearFilters()" style="margin-top: 12px; width: 100%; padding: 8px; background: none; border: 1px solid #e0e0e0; border-radius: 6px; cursor: pointer; font-size: 13px; color: #666;">
                Clear all filters
            </button>
        </div>
    </div>
    
    <div class="preset-buttons" style="position: absolute; bottom: 20px; left: 20px; display: flex; gap: 12px;">
        <button class="preset-btn" id="preset-peak" onclick="setPreset('peak', 3, 3, 3);">
            🎯 Peak
        </button>
        <button class="preset-btn" id="preset-chaos" onclick="setPreset('chaos', 0, 0, 0);">
            💀 Chaos
        </button>
        <button class="preset-btn" id="preset-balance" onclick="setPreset('balance', 2, 2, 2);">
            ⚖️ Balance
        </button>
        <button class="preset-btn" id="preset-sweet" onclick="setPreset('sweet', 2, 1, 2);">
            ✨ Sweet
        </button>
    </div>
    
    <div class="state-constellation" id="state-constellation">
        <svg id="constellation-svg" width="200" height="150"></svg>
    </div>
    
    <div class="legend" style="font-family: 'SF Mono', 'Consolas', monospace; font-size: 12px; white-space: pre;">
        <div style="font-weight: bold; margin-bottom: 8px;">LEGEND
━━━━━━━━━━━━━━━━━━━━━━</div>
        
        <div style="margin-bottom: 12px;">SURFACES
┌─────────────────────┐
│ <span style="color: #10b981;">████</span> Primary        │
│      Cognitive State│
│                     │
│ <span style="color: #991b1b;">████</span> Error Cascades │
│      (danger zones) │
│                     │  
│ <span style="color: #6d28d9;">████</span> Resonance      │
│      Harmonics      │
└─────────────────────┘</div>

        <div style="margin-bottom: 12px;">AXES
Signal Density
🙈 ← → 🔬
(blind)  (crystal)

Dependencies  
🌀 ← → 🎀
(chaos)  (elegant)

Error Handling
🌊 ← → 💠  
(flood)  (solid)

HEIGHT = Intensity
↑ High energy states
↓ Low energy states</div>

        <div>VERTEX COLORS
<span style="color: #10b981;">●</span> Transcendent (>2.7)
<span style="color: #84cc16;">●</span> Good (>2.0)
<span style="color: #fbbf24;">●</span> Functional (>1.3)
<span style="color: #f59e0b;">●</span> Degraded (>0.7)
<span style="color: #ef4444;">●</span> Struggling (>0)
<span style="color: #991b1b;">●</span> Catastrophic</div>
    </div>
    
    <script>
        // Load vibes data from external JSON file
        fetch('vibes-data.json')
            .then(response => response.json())
            .then(vibesData => {
                initializeVisualization(vibesData);
            })
            .catch(error => {
                console.error('Error loading vibes data:', error);
                document.body.innerHTML = '<div style="padding: 20px; color: red;">Error loading vibes data. Please ensure vibes-data.json is in the same directory.</div>';
            });
        
        function initializeVisualization(vibesData) {
        try {
        // Configuration
        const baseWidth = 1200;
        const baseHeight = 700;
        const width = Math.min(baseWidth, window.innerWidth);
        const height = Math.min(baseHeight, window.innerHeight * 0.9);
        
        // Better spatial composition with more aggressive scaling
        const availableHeight = height - 160; // Account for UI elements
        const scale = Math.min(180, availableHeight / 5, width / 10); // Increased from 140
        const gridSize = 3; // 0-3 for each axis (4 states)
        
        // Fixed isometric view angles
        const rotationY = Math.PI / 4;  // 45 degrees
        const rotationX = -Math.PI / 6; // 30 degrees down
        
        // SVG setup
        const svg = d3.select('#visualization')
            .attr('width', width)
            .attr('height', height)
            .attr('viewBox', `0 0 ${width} ${height}`);
        const defs = svg.append('defs');
        
        // Add noise texture filter for surfaces
        const noiseFilter = defs.append('filter')
            .attr('id', 'noise-texture')
            .attr('x', '0%')
            .attr('y', '0%')
            .attr('width', '100%')
            .attr('height', '100%');
        
        noiseFilter.append('feTurbulence')
            .attr('baseFrequency', '0.9')
            .attr('numOctaves', '1')
            .attr('seed', '2')
            .attr('stitchTiles', 'stitch');
        
        noiseFilter.append('feComponentTransfer')
            .append('feFuncA')
            .attr('type', 'discrete')
            .attr('tableValues', '0 0.02 0.04 0.06');
        
        noiseFilter.append('feComposite')
            .attr('operator', 'over')
            .attr('in2', 'SourceGraphic');
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2 + 120})`);
        
        // Extract emoji mappings from vibesData - reversed so 3 is best
        const signalEmojis = vibesData.dimensions.signalDensity.levels;
        const dependencyEmojis = vibesData.dimensions.dependencies.levels;
        const errorEmojis = vibesData.dimensions.errorSurface.levels;
        
        // State history for constellation
        const stateHistory = [];
        const stateFrequency = {};
        let stateHistoryMax = 20;
        
        // Current state values
        let currentState = {
            signal: 3,
            dependencies: 3,
            error: 3
        };
        
        // Create lookup maps for vibes data
        const vibesLookup = {};
        const codeExamples = {};
        
        // Build lookup maps from vibesData
        vibesData.vibes.forEach(vibe => {
            vibesLookup[vibe.binary] = vibe;
            if (vibe.code) {
                codeExamples[vibe.binary] = {
                    lang: vibe.code.language,
                    code: vibe.code.example
                };
            }
        });
        
        // Generate natural language descriptions for each vertex
        function getStateDescription(signal, dependencies, error) {
            const s = signalEmojis[signal];
            const d = dependencyEmojis[dependencies];
            const e = errorEmojis[error];
            
            // Look up the state in vibesLookup
            const stateKey = `${signal}-${dependencies}-${error}`;
            const vibeData = vibesLookup[stateKey];
            
            if (vibeData) {
                return {
                    emoji: `${s}${d}${e}`,
                    title: vibeData.title,
                    description: vibeData.forHumans,
                    phenomenology: vibeData.phenomenology,
                    code: codeExamples[stateKey]
                };
            } else {
                return {
                    emoji: `${s}${d}${e}`,
                    title: "Unnamed State",
                    description: `Signal ${signal}, Dependencies ${dependencies}, Error ${error} - a unique phenomenological combination awaiting exploration.`,
                    phenomenology: null,
                    code: null
                };
            }
        }
        
        // OLD PHENOMENOLOGY DATA REMOVED - NOW LOADED FROM vibes-data.json
        const phenomenology = {
                // Total collapse
                "0-0-0": {
                    title: "Absolute Void",
                    description: "Complete system failure. Like drowning in static during an earthquake while blindfolded. Every thought dissolves before forming, every connection tears before linking. Pure cognitive entropy."
                },
                // Signal axis degraded
                "0-1-0": {
                    title: "Blind in Tangles", 
                    description: "Can't see anything but feel the knots everywhere. Like trying to untangle Christmas lights in pitch darkness while wearing oven mitts."
                },
                "0-2-0": {
                    title: "Organized Blindness",
                    description: "Structure exists but you can't perceive it. Like being in a perfectly organized library with all the lights off - everything's there but unreachable."
                },
                "0-3-0": {
                    title: "Blind Ballet",
                    description: "Perfect choreography you can't see. Dependencies flow like water but you're groping in darkness. Smooth systematic failure."
                },
                // Dependency axis degraded
                "1-0-0": {
                    title: "Squinting at Chaos",
                    description: "Barely making out shapes in a tornado. Every glimpse reveals more chaos. Like reading through fogged glasses during a hurricane."
                },
                "2-0-0": {
                    title: "Clear View of Chaos",
                    description: "Perfect vision of total systemic failure. Like watching a building collapse in slow motion - every detail crystal clear, nothing you can do."
                },
                "3-0-0": {
                    title: "Microscopic Chaos",
                    description: "Every chaotic detail in perfect resolution. Like using an electron microscope to watch molecules in Brownian motion - ultimate clarity of ultimate disorder."
                },
                // Error axis degraded
                "0-0-1": {
                    title: "Dissolving in Darkness",
                    description: "Can't see, can't connect, structure liquifying. Like being blindfolded on a sinking ship in a whirlpool."
                },
                "0-0-2": {
                    title: "Frozen Void",
                    description: "Blind, chaotic, but at least stable in its dysfunction. Like being trapped in ice during a blizzard - horrible but solid."
                },
                "0-0-3": {
                    title: "Diamond Prison",
                    description: "Perfect structure containing perfect darkness and chaos. Like being sealed in a flawless crystal sphere floating in a tornado."
                },
                // Mixed states - low overall
                "1-1-1": {
                    title: "Struggling System",
                    description: "Everything degraded but not quite failing. Like trying to read smudged text through dirty glasses while juggling - possible but exhausting."
                },
                "0-1-1": {
                    title: "Dark Tangles Melting",
                    description: "Can't see, everything's knotted, and it's all dissolving. Like trying to solve a Rubik's cube underwater at night."
                },
                "1-0-1": {
                    title: "Squinting at Liquid Chaos",
                    description: "Barely seeing chaos that won't hold still. Like watching a lava lamp through frosted glass during an earthquake."
                },
                "1-1-0": {
                    title: "Foggy Knots Drowning",
                    description: "Degraded vision, tangled connections, cascading errors. Like debugging spaghetti code through tears during a flood."
                },
                // Mid-range states
                "2-2-2": {
                    title: "Functional Plateau",
                    description: "Everything works adequately. Like reading a decent book with good lighting in a comfortable chair - nothing spectacular but solidly pleasant."
                },
                "1-2-3": {
                    title: "Squinting at Good Structure",
                    description: "Vision degraded but dependencies flow well on solid foundation. Like needing glasses but having excellent organizational systems."
                },
                "3-1-2": {
                    title: "Perfect Vision of Tangles",
                    description: "Can see every knot in excruciating detail on stable ground. Like having x-ray vision of a messy room - clarity makes the chaos worse."
                },
                "2-3-1": {
                    title: "Clear Flows Melting",
                    description: "Good clarity, perfect flow, but foundation liquifying. Like watching a beautiful ice sculpture melt - exquisite while it lasts."
                },
                // High-functioning states
                "3-2-3": {
                    title: "Crystalline Complexity",
                    description: "Perfect clarity navigating intentional complexity on solid foundation. Like a master watchmaker seeing every gear's purpose."
                },
                "2-3-3": {
                    title: "Clear Perfect Flow",
                    description: "Good vision of dependencies flowing flawlessly on bedrock. Like watching a murmuration of starlings - complex but harmonious."
                },
                "3-3-2": {
                    title: "Transcendent but Fragile",
                    description: "Perfect clarity and flow on ice. Like performing brain surgery on a frozen lake - exquisite precision, precarious foundation."
                },
                // Peak state
                "3-3-3": {
                    title: "Absolute Transcendence",
                    description: "Peak phenomenological state. Every pattern resonates with crystalline clarity. Dependencies flow like music. Foundation unshakeable. Time dilates, understanding arrives before questions form."
                },
                // More mixed states with phenomenological richness
                "2-1-3": {
                    title: "Clear Knots on Bedrock",
                    description: "See the tangles clearly, foundation solid. Like untangling jewelry with good light and steady hands - tedious but doable."
                },
                "1-3-2": {
                    title: "Squinting at Perfection",
                    description: "Perfect flow barely perceived on shaky ground. Like watching ballet through a keyhole during mild tremors."
                },
                "3-0-3": {
                    title: "Perfect Vision of Perfect Chaos",
                    description: "Ultimate clarity viewing ultimate disorder on unshakeable foundation. Like God watching entropy - omniscient helplessness."
                },
                "0-3-3": {
                    title: "Blind Trust in Perfect System",
                    description: "Can't see but everything flows perfectly on solid ground. Like being blindfolded on a luxury train - smooth progress into unknown."
                },
                "2-2-0": {
                    title: "Functional Drowning",
                    description: "Clear enough, organized enough, but errors cascade. Like competently arranging deck chairs on the Titanic."
                },
                "1-1-3": {
                    title: "Struggling on Bedrock",
                    description: "Poor vision, tangles everywhere, but foundation holds. Like fumbling with keys in dim light - frustrating but you'll get there."
                },
                "3-2-1": {
                    title: "Perfect Sight of Dissolution",
                    description: "Crystal clarity watching good structure melt. Like HD footage of ice shelves calving - beautiful horror in perfect detail."
                },
                "0-2-2": {
                    title: "Blind but Structured",
                    description: "Can't see but complexity well-managed on stable base. Like a blind pianist who knows every key by touch."
                },
                // Continue with remaining combinations...
                "2-0-2": {
                    title: "Watching Stable Chaos",
                    description: "Clear view of chaos that at least stays put. Like observing a frozen explosion - destructive but static."
                },
                "0-1-2": {
                    title: "Dark Tangles Holding",
                    description: "Blind in knots but stable. Like being lost in a maze at night, but at least the walls aren't moving."
                },
                "1-2-1": {
                    title: "Fuzzy Flow Failing",
                    description: "Squinting at decent organization that's starting to fail. Like reading instructions in fading light as rain begins."
                },
                "3-1-1": {
                    title: "Perfect View of Failing Tangles",
                    description: "See every knot clearly as they pull tighter and structure weakens. Like watching a sweater unravel in slow motion HD."
                },
                "2-1-2": {
                    title: "Clear Tangles Stabilizing",
                    description: "See the knots clearly, foundation solidifying. Like untangling headphones with good light - annoying but manageable."
                },
                "1-3-1": {
                    title: "Glimpsing Perfect Dissolution",
                    description: "Barely seeing perfect flow as it melts away. Like watching a sand mandala dissolve through tears."
                },
                "0-2-3": {
                    title: "Blind Competence",
                    description: "Can't see but muscle memory navigates solid structure perfectly. Like a master chef cooking by smell and touch alone."
                },
                "3-0-2": {
                    title: "Microscopic Stable Chaos",
                    description: "Every chaotic detail crystal clear, at least it's frozen. Like studying Brownian motion in a gel - random but contained."
                },
                "2-3-2": {
                    title: "Clear Flow on Ice",
                    description: "Good vision of perfect patterns on fragile foundation. Like figure skating - beautiful but one wrong move means falling."
                },
                "1-2-2": {
                    title: "Functional Fog",
                    description: "Degraded but everything basically works. Like driving familiar roads in light fog - slow but steady."
                },
                "0-3-1": {
                    title: "Blind Perfect Cascade",
                    description: "Can't see but feel the perfect flow failing. Like a musician going deaf mid-performance - muscle memory fights inevitable decay."
                },
                "3-1-3": {
                    title: "Perfect Sight of Solid Knots",
                    description: "See every tangle in perfect detail on unshakeable foundation. Like having X-ray vision of your own broken bones - clarity without relief."
                },
                "2-0-3": {
                    title: "Clear Chaos Crystallized",
                    description: "Good view of chaos frozen in crystal. Like a photograph of an explosion - destructive power held in perfect stasis."
                },
                "1-0-2": {
                    title: "Squinting at Frozen Chaos",
                    description: "Barely seeing stable disorder. Like looking at TV static through foggy glasses - doubly unclear but not changing."
                },
                "0-1-3": {
                    title: "Blind in Perfect Knots",
                    description: "Can't see the tangles but they're solid as rock. Like being trapped in an invisible crystal maze - confusing but unbreakable."
                },
                "3-2-2": {
                    title: "Perfect Complexity Balanced",
                    description: "Crystal clarity through managed complexity on stable ground. Like a surgeon seeing every vessel while operating - controlled precision."
                },
                "2-2-3": {
                    title: "Solid Competence",
                    description: "Everything good enough on perfect foundation. Like a well-maintained machine - not cutting-edge but utterly reliable."
                },
                "1-3-3": {
                    title: "Squinting at Paradise",
                    description: "Perfect flow on perfect foundation, barely perceived. Like glimpsing heaven through a keyhole - tantalizing perfection just out of reach."
                },
                "0-0-1": {
                    title: "Void Liquifying",
                    description: "Complete darkness, total chaos, starting to melt. Like being in a sensory deprivation tank that's slowly heating up."
                },
                "2-1-0": {
                    title: "Seeing Knots Cascade",
                    description: "Clear view of tangles pulling everything down. Like watching dominoes fall in slow motion - inevitable systematic collapse."
                },
                "3-3-1": {
                    title: "Perfection Melting",
                    description: "Absolute clarity and flow starting to liquify. Like the last moments of a perfect dream as you wake - sublime dissolution."
                },
                "0-2-1": {
                    title: "Blind Structure Failing",
                    description: "Can't see but feel the good organization starting to slip. Like a blind person feeling their familiar furniture being rearranged."
                },
                "3-0-0": {
                    title: "Perfect Sight of Total Chaos",
                    description: "Ultimate clarity viewing ultimate systemic failure. Like having god's eye view of the heat death of the universe."
                },
                "1-1-2": {
                    title: "Stable Struggle",
                    description: "Everything difficult but holding steady. Like reading by candlelight during a power outage - not ideal but it works."
                },
                "2-3-0": {
                    title: "Clear Perfect Cascade",
                    description: "Watching beautiful patterns collapse perfectly. Like observing a championship domino run - mesmerizing destruction."
                },
                "1-0-3": {
                    title: "Glimpsing Solid Chaos",
                    description: "Barely seeing chaos that's frozen in crystal. Like squinting at a spider preserved in amber - disorder made permanent."
                },
                "0-3-2": {
                    title: "Blind Flow on Ice",
                    description: "Can't see but feeling perfect patterns on shaky ground. Like ice dancing blindfolded - grace despite precariousness."
                },
                "3-1-0": {
                    title: "Perfect View of Cascade",
                    description: "Crystal clarity watching knots trigger system collapse. Like time-lapse photography of a building demolition - every detail of destruction visible."
                },
                "2-0-1": {
                    title: "Watching Chaos Melt",
                    description: "Clear view of disorder becoming liquid. Like watching a Jackson Pollock painting in the rain - chaos becoming more chaotic."
                },
                "1-2-0": {
                    title: "Fuzzy Structure Failing",
                    description: "Squinting at decent organization as it collapses. Like trying to read a map in wind and rain - was useful, now dissolving."
                }
            }; // End of removed phenomenology object
        
        // 3D projection
        function project3D(x, y, z) {
            const x1 = x * Math.cos(rotationY) - z * Math.sin(rotationY);
            const y1 = y;
            const z1 = x * Math.sin(rotationY) + z * Math.cos(rotationY);
            
            const x2 = x1;
            const y2 = y1 * Math.cos(rotationX) - z1 * Math.sin(rotationX);
            const z2 = y1 * Math.sin(rotationX) + z1 * Math.cos(rotationX);
            
            return {
                x: x2 * scale,
                y: -y2 * scale,
                z: z2
            };
        }
        
        // Surface functions for different phenomenological layers - bounded to cube
        function primarySurface(signal, dependencies) {
            // Main phenomenological surface - higher values are better
            const s = signal / 3;  // Normalize to 0-1
            const d = dependencies / 3;
            // Peak at (3,3) = (1,1) normalized
            const base = 3 * Math.exp(-((1-s) * (1-s) + (1-d) * (1-d)) * 2);
            const interaction = 0.5 * Math.sin(signal * Math.PI / 3) * Math.cos(dependencies * Math.PI / 3);
            // Clamp to reasonable bounds
            return Math.max(-1, Math.min(3, base + interaction));
        }
        
        function errorSurface(signal, dependencies) {
            // Error cascade surface - shows where things break (low values = bad)
            const s = signal / 3;
            const d = dependencies / 3;
            // Catastrophic when both are low (near 0)
            if (s < 0.4 && d < 0.4) {
                return Math.max(-2, -2 * Math.exp((0.4 - s) * (0.4 - d) * 6));
            }
            return 0;
        }
        
        function resonanceSurface(signal, dependencies) {
            // Resonance surface - where imperfect states create surprising harmony
            if ((signal === 2 && dependencies === 1) || (signal === 1 && dependencies === 2)) {
                return 1;
            }
            if (signal === dependencies && signal > 0 && signal < 3) {
                return 0.5;
            }
            return 0;
        }
        
        // Generate mesh for a surface
        function generateSurfaceMesh(surfaceFunc, offset = 0) {
            const points = [];
            
            for (let i = 0; i <= gridSize; i++) {
                points[i] = [];
                for (let j = 0; j <= gridSize; j++) {
                    const height = surfaceFunc(i, j) + offset;
                    points[i][j] = {
                        x: i,
                        y: height,
                        z: j,
                        projected: project3D(i, height, j)
                    };
                }
            }
            
            return points;
        }
        
        // Convert mesh to quads
        function meshToQuads(mesh) {
            const quads = [];
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const p1 = mesh[i][j];
                    const p2 = mesh[i+1][j];
                    const p3 = mesh[i+1][j+1];
                    const p4 = mesh[i][j+1];
                    
                    const avgHeight = (p1.y + p2.y + p3.y + p4.y) / 4;
                    const avgZ = (p1.projected.z + p2.projected.z + p3.projected.z + p4.projected.z) / 4;
                    
                    quads.push({
                        points: [p1, p2, p3, p4],
                        avgHeight: avgHeight,
                        avgZ: avgZ
                    });
                }
            }
            
            quads.sort((a, b) => a.avgZ - b.avgZ);
            return quads;
        }
        
        // Color schemes for different surfaces matching VIBES emoji aesthetics
        const primaryColorScale = d3.scaleSequential()
            .domain([-2, 5])
            .interpolator(t => {
                // Match emoji vibes: 
                // Green (🔬🎀💠 crystalline) → Yellow (🔍🪢🧊 functional) → Orange (👓🧶💧 degraded) → Red (🙈🌀🌊 catastrophic)
                if (t < 0.33) {
                    return d3.interpolateRgb("#10b981", "#84cc16")(t * 3); // Emerald to lime
                } else if (t < 0.66) {
                    return d3.interpolateRgb("#84cc16", "#f59e0b")((t - 0.33) * 3); // Lime to amber
                } else {
                    return d3.interpolateRgb("#f59e0b", "#dc2626")((t - 0.66) * 3); // Amber to red
                }
            });
        
        const errorColorScale = d3.scaleSequential()
            .domain([-3, 0])
            .interpolator(t => d3.interpolateRgb("#991b1b", "#450a0a")(t)); // Deep reds for catastrophic states
        
        const resonanceColorScale = d3.scaleSequential()
            .domain([0, 2])
            .interpolator(t => d3.interpolateRgb("#a78bfa", "#6d28d9")(t)); // Violet for unexpected harmonies
        
        // Draw all surfaces
        function drawSurfaces() {
            // Clear previous
            g.selectAll('.surface-path').remove();
            g.selectAll('.vertex-point').remove();
            g.selectAll('.axis-line').remove();
            g.selectAll('.axis-label').remove();
            g.selectAll('.cube-edge').remove();
            g.selectAll('.reference-point').remove();
            
            // Draw cube wireframe first
            drawCubeWireframe();
            
            // Generate meshes for different surfaces
            const surfaces = [
                {
                    mesh: generateSurfaceMesh(primarySurface),
                    colorScale: primaryColorScale,
                    opacity: 0.7,
                    class: 'primary-surface'
                },
                {
                    mesh: generateSurfaceMesh(errorSurface, 3),
                    colorScale: errorColorScale,
                    opacity: 0.5,
                    class: 'error-surface'
                },
                {
                    mesh: generateSurfaceMesh(resonanceSurface, 1),
                    colorScale: resonanceColorScale,
                    opacity: 0.4,
                    class: 'resonance-surface'
                }
            ];
            
            // Draw each surface with enhanced transparency for layering
            surfaces.forEach((surface, idx) => {
                const quads = meshToQuads(surface.mesh);
                
                g.selectAll(`.surface-path.${surface.class}`)
                    .data(quads)
                    .enter()
                    .append('path')
                    .attr('class', `surface-path ${surface.class}`)
                    .attr('d', d => {
                        const points = d.points;
                        return `M ${points[0].projected.x} ${points[0].projected.y} 
                                L ${points[1].projected.x} ${points[1].projected.y}
                                L ${points[2].projected.x} ${points[2].projected.y}
                                L ${points[3].projected.x} ${points[3].projected.y} Z`;
                    })
                    .attr('fill', d => surface.colorScale(d.avgHeight))
                    .attr('fill-opacity', d => {
                        // Transparency gradient from center to edge
                        const centerX = 1.5;
                        const centerZ = 1.5;
                        const quadCenterX = (d.points[0].x + d.points[2].x) / 2;
                        const quadCenterZ = (d.points[0].z + d.points[2].z) / 2;
                        const distanceFromCenter = Math.sqrt(
                            Math.pow(quadCenterX - centerX, 2) + 
                            Math.pow(quadCenterZ - centerZ, 2)
                        );
                        const maxDistance = Math.sqrt(2.25 + 2.25); // Distance from center to corner
                        const edgeFade = Math.max(0.3, 1 - (distanceFromCenter / maxDistance) * 0.4);
                        return surface.opacity * edgeFade;
                    })
                    .attr('stroke', d => {
                        // Enhanced edge highlighting with Fresnel-like effect
                        const heightVariance = Math.abs(d.points[0].y - d.points[2].y);
                        const avgHeight = d.avgHeight;
                        
                        // Edge detection for Fresnel effect
                        const centerX = 1.5;
                        const centerZ = 1.5;
                        const quadCenterX = (d.points[0].x + d.points[2].x) / 2;
                        const quadCenterZ = (d.points[0].z + d.points[2].z) / 2;
                        const distanceFromCenter = Math.sqrt(
                            Math.pow(quadCenterX - centerX, 2) + 
                            Math.pow(quadCenterZ - centerZ, 2)
                        );
                        const maxDistance = Math.sqrt(2.25 + 2.25);
                        const edgeIntensity = distanceFromCenter / maxDistance;
                        
                        if (heightVariance > 1) {
                            return `rgba(255, 255, 255, ${0.3 + edgeIntensity * 0.4})`;
                        } else {
                            return `rgba(0, 0, 0, ${0.1 + edgeIntensity * 0.2})`;
                        }
                    })
                    .attr('stroke-width', d => {
                        const heightVariance = Math.abs(d.points[0].y - d.points[2].y);
                        return heightVariance > 1 ? 1.2 : 0.5;
                    });
            });
            
            // drawVertices(); // Removed - no more dots
            drawAxes();
            drawProjections();
            drawPhenomenologicalTerritories();
            drawLivingAnnotations();
            // drawSurfaceLabels(); // Removed - too cluttered
            
            // Update constellation after drawing
            updateConstellation();
        }
        
        function drawProjections() {
            // Remove old projections
            g.selectAll('.projection-line').remove();
            g.selectAll('.intersection-point').remove();
            
            // Calculate intersection point
            const yValue = -1 + (currentState.error * 4/3);
            const intersectionPoint = project3D(currentState.signal, yValue, currentState.dependencies);
            
            // Draw projection lines
            const projections = [
                // To X axis
                {
                    from: intersectionPoint,
                    to: project3D(currentState.signal, 0, 0)
                },
                // To Y axis
                {
                    from: intersectionPoint,
                    to: project3D(0, yValue, 0)
                },
                // To Z axis
                {
                    from: intersectionPoint,
                    to: project3D(0, 0, currentState.dependencies)
                }
            ];
            
            projections.forEach(proj => {
                g.append('line')
                    .attr('class', 'projection-line')
                    .attr('x1', proj.from.x)
                    .attr('y1', proj.from.y)
                    .attr('x2', proj.to.x)
                    .attr('y2', proj.to.y);
            });
            
            // Draw intersection point with dynamic color glow
            const currentColor = `rgb(${Math.round(255 * (currentState.signal / 3))}, ${Math.round(255 * (currentState.dependencies / 3))}, ${Math.round(255 * (currentState.error / 3))})`;
            g.append('circle')
                .attr('class', 'intersection-point')
                .attr('cx', intersectionPoint.x)
                .attr('cy', intersectionPoint.y)
                .attr('r', 8)
                .attr('fill', '#ffffff')
                .attr('stroke', currentColor)
                .attr('stroke-width', 3)
                .style('filter', `drop-shadow(0 0 15px ${currentColor})`);
        }
        
        function drawSurfaceLabels() {
            // Remove old labels
            g.selectAll('.surface-label').remove();
            
            // Define label positions and text
            const labels = [
                {
                    text: "Primary Cognitive State",
                    x: 1.5,
                    y: primarySurface(1.5, 1.5) + 0.5,
                    z: 1.5,
                    color: '#10b981'
                },
                {
                    text: "Error Cascade Zones",
                    x: 0.5,
                    y: errorSurface(0.5, 0.5) + 2.5,
                    z: 0.5,
                    color: '#991b1b'
                },
                {
                    text: "Resonance Harmonics",
                    x: 2,
                    y: resonanceSurface(2, 1) + 1.5,
                    z: 1,
                    color: '#6d28d9'
                }
            ];
            
            // Add labels
            labels.forEach(label => {
                const projected = project3D(label.x, label.y, label.z);
                
                const labelGroup = g.append('g')
                    .attr('class', 'surface-label')
                    .attr('transform', `translate(${projected.x}, ${projected.y})`);
                
                // Background for readability
                labelGroup.append('rect')
                    .attr('x', -60)
                    .attr('y', -10)
                    .attr('width', 120)
                    .attr('height', 20)
                    .attr('fill', 'rgba(255, 255, 255, 0.9)')
                    .attr('stroke', label.color)
                    .attr('stroke-width', 1)
                    .attr('rx', 3);
                
                // Label text
                labelGroup.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', 4)
                    .attr('fill', label.color)
                    .attr('font-size', '12px')
                    .attr('font-weight', 'bold')
                    .text(label.text);
            });
        }
        
        function drawCubeWireframe() {
            // Simple cube wireframe from 0-3 on each axis
            // Draw the 12 edges of the cube
            const cubeEdges = [
                // Bottom face (y=low)
                [{x:0,y:-1,z:0}, {x:3,y:-1,z:0}],
                [{x:3,y:-1,z:0}, {x:3,y:-1,z:3}],
                [{x:3,y:-1,z:3}, {x:0,y:-1,z:3}],
                [{x:0,y:-1,z:3}, {x:0,y:-1,z:0}],
                // Top face (y=high)
                [{x:0,y:4,z:0}, {x:3,y:4,z:0}],
                [{x:3,y:4,z:0}, {x:3,y:4,z:3}],
                [{x:3,y:4,z:3}, {x:0,y:4,z:3}],
                [{x:0,y:4,z:3}, {x:0,y:4,z:0}],
                // Vertical edges
                [{x:0,y:-1,z:0}, {x:0,y:4,z:0}],
                [{x:3,y:-1,z:0}, {x:3,y:4,z:0}],
                [{x:3,y:-1,z:3}, {x:3,y:4,z:3}],
                [{x:0,y:-1,z:3}, {x:0,y:4,z:3}]
            ];
            
            // Draw edges
            cubeEdges.forEach(edge => {
                const p1 = project3D(edge[0].x, edge[0].y, edge[0].z);
                const p2 = project3D(edge[1].x, edge[1].y, edge[1].z);
                
                g.append('line')
                    .attr('class', 'cube-edge')
                    .attr('x1', p1.x)
                    .attr('y1', p1.y)
                    .attr('x2', p2.x)
                    .attr('y2', p2.y);
            });
            
            // Draw corner points for clarity
            const corners = [
                {x:0,y:0,z:0}, {x:3,y:0,z:0}, {x:3,y:0,z:3}, {x:0,y:0,z:3}
            ];
            
            corners.forEach(corner => {
                const p = project3D(corner.x, primarySurface(corner.x, corner.z), corner.z);
                g.append('circle')
                    .attr('class', 'cube-corner')
                    .attr('cx', p.x)
                    .attr('cy', p.y)
                    .attr('r', 5)
                    .attr('fill', '#444')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2);
            });
        }
        
        function drawVertices() {
            const vertices = [];
            
            // Generate all vertex points
            for (let signal = 0; signal <= gridSize; signal++) {
                for (let dependencies = 0; dependencies <= gridSize; dependencies++) {
                    // Use primary surface height for vertex placement
                    const height = primarySurface(signal, dependencies);
                    const projected = project3D(signal, height, dependencies);
                    
                    // Generate vertices for each error state at this signal/dependency combination
                    for (let error = 0; error <= gridSize; error++) {
                        const errorOffset = error * 0.5; // Slight vertical offset for error states
                        const adjustedHeight = height - errorOffset;
                        const projectedWithError = project3D(signal, adjustedHeight, dependencies);
                        
                        vertices.push({
                            signal: signal,
                            dependencies: dependencies,
                            error: error,
                            height: adjustedHeight,
                            projected: projectedWithError,
                            description: getStateDescription(signal, dependencies, error)
                        });
                    }
                }
            }
            
            // Sort by depth
            vertices.sort((a, b) => a.projected.z - b.projected.z);
            
            // Draw vertices
            g.selectAll('.vertex-point')
                .data(vertices)
                .enter()
                .append('circle')
                .attr('class', 'vertex-point')
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y)
                .attr('r', 4)
                .attr('fill', d => {
                    // Color based on overall VIBES state quality per spec
                    const totalScore = (d.signal + d.dependencies + d.error) / 9; // Normalize to 0-1
                    if (totalScore > 0.9) return '#10b981';  // Transcendent (>2.7/3)
                    if (totalScore > 0.67) return '#84cc16'; // Good (>2.0/3)
                    if (totalScore > 0.43) return '#fbbf24'; // Functional (>1.3/3)
                    if (totalScore > 0.23) return '#f59e0b'; // Degraded (>0.7/3)
                    if (totalScore > 0) return '#ef4444';    // Struggling (>0)
                    return '#991b1b'; // Catastrophic (≤0)
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                // Vertices removed - no click handlers needed
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('r', 6);
                    
                    // Show code hint on hover
                    const hintGroup = g.append('g')
                        .attr('class', 'code-hint-group')
                        .attr('transform', `translate(${d.projected.x + 10}, ${d.projected.y - 10})`);
                    
                    // Background rect
                    const hintRect = hintGroup.append('rect')
                        .attr('x', 0)
                        .attr('y', -20)
                        .attr('width', 180)
                        .attr('height', 30)
                        .attr('rx', 4)
                        .attr('fill', 'rgba(255, 255, 255, 0.95)')
                        .attr('stroke', 'rgba(0, 0, 0, 0.1)')
                        .attr('stroke-width', 1);
                    
                    // Check if code exists for this state
                    const stateKey = `${d.signal}-${d.dependencies}-${d.error}`;
                    const codeExample = codeExamples[stateKey];
                    
                    if (codeExample) {
                        // Language icon
                        const langMap = {
                            haskell: 'hs',
                            javascript: 'js',
                            python: 'py',
                            java: 'java',
                            rust: 'rs',
                            clojure: 'clj',
                            go: 'go',
                            typescript: 'ts'
                        };
                        
                        hintGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 0)
                            .style('font-size', '11px')
                            .style('font-weight', 'bold')
                            .style('fill', '#4488ff')
                            .text(langMap[codeExample.language] || codeExample.language);
                        
                        // Code preview (first line or snippet)
                        const codeLines = codeExample.code.split('\n');
                        const preview = codeLines[0].length > 20 ? 
                            codeLines[0].substring(0, 20) + '...' : 
                            codeLines[0];
                        
                        hintGroup.append('text')
                            .attr('x', 40)
                            .attr('y', 0)
                            .style('font-size', '11px')
                            .style('font-family', 'monospace')
                            .style('fill', '#666')
                            .text(preview);
                    } else {
                        hintGroup.append('text')
                            .attr('x', 10)
                            .attr('y', 0)
                            .style('font-size', '11px')
                            .style('fill', '#999')
                            .text('Click for details');
                    }
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).attr('r', 4);
                    g.selectAll('.code-hint-group').remove();
                })
                .on('click', function(event, d) {
                    showCodeModal(d.signal, d.dependencies, d.error);
                });
        }
        
        function drawAxes() {
            // Remove old axes
            g.selectAll('.axis-rail').remove();
            g.selectAll('.axis-emoji').remove();
            g.selectAll('.axis-tick').remove();
            g.selectAll('.axis-orb').remove();
            g.selectAll('.axis-segment').remove();
            g.selectAll('.axis-group').remove();
            g.selectAll('.connecting-line').remove();
            
            // Current values from state
            const currentSignal = currentState.signal;
            const currentDeps = currentState.dependencies;
            const currentError = currentState.error;
            
            // Define 4 distinct color segments
            const segmentColors = ['#dc2626', '#f59e0b', '#84cc16', '#10b981']; // Red, Orange, Lime, Green
            
            // Offset for positioning axes outside cube (25px for true external positioning)
            const axisOffset = 25;
            
            // ===== X-axis (Signal Density) - Bottom front edge =====
            // Use same Z coordinate as cube front edge (Z=0) for perfect alignment
            const xAxisGroup = g.append('g').attr('class', 'x-axis-group');
            
            for (let i = 0; i < 4; i++) {
                // Match cube's front edge coordinates exactly: Z=0, offset Y downward after projection
                const segStart3D = project3D(Math.max(-0.5, i - 0.5), -1, 0);
                const segEnd3D = project3D(Math.min(3.5, i + 0.5), -1, 0);
                const offsetY = axisOffset; // Move down from cube edge
                
                // Draw main segment using projected coordinates
                xAxisGroup.append('line')
                    .attr('class', 'axis-segment x-axis')
                    .attr('data-value', i)
                    .attr('x1', segStart3D.x)
                    .attr('y1', segStart3D.y + offsetY)
                    .attr('x2', segEnd3D.x)
                    .attr('y2', segEnd3D.y + offsetY)
                    .attr('stroke', segmentColors[i])
                    .attr('stroke-width', 20)
                    .attr('stroke-linecap', i === 0 || i === 3 ? 'round' : 'butt')
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', function() {
                        d3.select(this)
                            .attr('stroke-width', 24)
                            .attr('opacity', 1)
                            .style('filter', 'drop-shadow(0 0 10px currentColor)');
                        // Show connecting line to cube
                        const value = parseInt(d3.select(this).attr('data-value'));
                        const cubePoint = project3D(value, -1, 0);
                        g.append('line')
                            .attr('class', 'connecting-line')
                            .attr('x1', project3D(value, -1, 0).x)
                            .attr('y1', xAxisY)
                            .attr('x2', cubePoint.x)
                            .attr('y2', cubePoint.y)
                            .attr('stroke', segmentColors[i])
                            .attr('stroke-width', 2)
                            .attr('stroke-dasharray', '3,3')
                            .attr('opacity', 0.5);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke-width', 20)
                            .attr('opacity', 0.7)
                            .style('filter', null);
                        g.selectAll('.connecting-line').remove();
                    })
                    .on('click', function() {
                        const value = parseInt(d3.select(this).attr('data-value'));
                        updateAxisValue('signal', value);
                    });
                
                // Position tick marks using corrected coordinates
                const tick3D = project3D(i, -1, 0);
                g.append('line')
                    .attr('class', 'axis-tick')
                    .attr('x1', tick3D.x)
                    .attr('y1', tick3D.y + offsetY - 8)
                    .attr('x2', tick3D.x)
                    .attr('y2', tick3D.y + offsetY + 8)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 3);
                
                // Position labels using corrected coordinates
                g.append('text')
                    .attr('class', 'axis-tick-label')
                    .attr('x', tick3D.x)
                    .attr('y', tick3D.y + offsetY + 25)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#666')
                    .text(i);
                
                // Add grid line extending into space
                const gridEnd = project3D(i, 1, 0);
                g.append('line')
                    .attr('class', 'grid-line')
                    .attr('x1', tick3D.x)
                    .attr('y1', tick3D.y + offsetY)
                    .attr('x2', gridEnd.x)
                    .attr('y2', gridEnd.y)
                    .attr('stroke', 'rgba(0, 0, 0, 0.08)')
                    .attr('stroke-width', 0.5)
                    .attr('stroke-dasharray', '2,2')
                    .attr('opacity', 0.5);
            }
            
            // Add segment borders between X-axis segments
            for (let i = 0; i < 3; i++) {
                const borderPos = project3D(i + 0.5, -1, 0);
                xAxisGroup.append('line')
                    .attr('class', 'axis-segment-border')
                    .attr('x1', borderPos.x)
                    .attr('y1', borderPos.y + axisOffset - 10)
                    .attr('x2', borderPos.x)
                    .attr('y2', borderPos.y + axisOffset + 10)
                    .attr('stroke', 'rgba(255, 255, 255, 0.8)')
                    .attr('stroke-width', 1);
            }
            
            // X axis emoji endpoints using corrected coordinates
            const xStart3D = project3D(-0.5, -1, 0);
            const xEnd3D = project3D(3.5, -1, 0);
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', xStart3D.x - 20)
                .attr('y', xStart3D.y + axisOffset + 5)
                .attr('text-anchor', 'end')
                .style('font-size', '24px')
                .text('🙈');
            
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', xEnd3D.x + 20)
                .attr('y', xEnd3D.y + axisOffset + 5)
                .attr('text-anchor', 'start')
                .style('font-size', '24px')
                .text('🔬');
            
            // X axis current position orb with pulsing animation
            const xCurrentPos = project3D(currentSignal, -1, 0);
            g.append('circle')
                .attr('class', 'axis-orb axis-orb-current x-orb')
                .attr('cx', xCurrentPos.x)
                .attr('cy', xCurrentPos.y + axisOffset)
                .attr('r', 12)
                .attr('fill', '#4488ff')
                .attr('stroke', '#fff')
                .attr('stroke-width', 3);
            
            // ===== Y-axis (Error Surface) - Using 3D→2D projection like X and Z =====
            const yAxisGroup = g.append('g').attr('class', 'y-axis-group');
            
            // Draw Y axis as stepped/notched segments using 3D space
            for (let i = 0; i < 4; i++) {
                // Define Y-axis in 3D cube space (left edge, outside cube bounds)
                const segStart3D = project3D(-0.5, -1 + (Math.max(-0.5, i - 0.5) * 4/3), -0.5);
                const segEnd3D = project3D(-0.5, -1 + (Math.min(3.5, i + 0.5) * 4/3), -0.5);
                // Offset further left from cube edge
                const offsetX = -25;
                
                // Draw main segment using projected 3D coordinates
                yAxisGroup.append('line')
                    .attr('class', 'axis-segment y-axis')
                    .attr('data-value', i)
                    .attr('x1', segStart3D.x + offsetX)
                    .attr('y1', segStart3D.y)
                    .attr('x2', segEnd3D.x + offsetX)
                    .attr('y2', segEnd3D.y)
                    .attr('stroke', segmentColors[i])
                    .attr('stroke-width', 20)
                    .attr('stroke-linecap', i === 0 || i === 3 ? 'round' : 'butt')
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', function() {
                        d3.select(this)
                            .attr('stroke-width', 24)
                            .attr('opacity', 1)
                            .style('filter', 'drop-shadow(0 0 10px currentColor)');
                        // Show connecting line to cube
                        const value = parseInt(d3.select(this).attr('data-value'));
                        const cubePoint = project3D(0, -1 + (value * 4/3), 0);
                        g.append('line')
                            .attr('class', 'connecting-line')
                            .attr('x1', segStart3D.x + offsetX)
                            .attr('y1', cubePoint.y)
                            .attr('x2', cubePoint.x)
                            .attr('y2', cubePoint.y)
                            .attr('stroke', segmentColors[i])
                            .attr('stroke-width', 2)
                            .attr('stroke-dasharray', '3,3')
                            .attr('opacity', 0.5);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke-width', 20)
                            .attr('opacity', 0.7)
                            .style('filter', null);
                        g.selectAll('.connecting-line').remove();
                    })
                    .on('click', function() {
                        const value = parseInt(d3.select(this).attr('data-value'));
                        updateAxisValue('error', value);
                    });
                
                // Position tick marks using 3D projection
                const tick3D = project3D(-0.5, -1 + (i * 4/3), -0.5);
                g.append('line')
                    .attr('class', 'axis-tick')
                    .attr('x1', tick3D.x + offsetX - 8)
                    .attr('y1', tick3D.y)
                    .attr('x2', tick3D.x + offsetX + 8)
                    .attr('y2', tick3D.y)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 3);
                
                // Position labels using 3D projection
                g.append('text')
                    .attr('class', 'axis-tick-label')
                    .attr('x', tick3D.x + offsetX - 25)
                    .attr('y', tick3D.y + 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#666')
                    .text(i);
            }
            
            // Y axis emoji endpoints using 3D projection
            const yStart3D = project3D(-0.5, -1.5, -0.5);
            const yEnd3D = project3D(-0.5, 4.5, -0.5);
            const offsetX = -25;
            
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', yStart3D.x + offsetX - 30)
                .attr('y', yStart3D.y + 5)
                .attr('text-anchor', 'middle')
                .style('font-size', '24px')
                .text('🌊');
            
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', yEnd3D.x + offsetX - 30)
                .attr('y', yEnd3D.y + 5)
                .attr('text-anchor', 'middle')
                .style('font-size', '24px')
                .text('💠');
            
            // Y axis current position orb with pulsing animation
            const yCurrentPos = project3D(-0.5, -1 + (currentError * 4/3), -0.5);
            g.append('circle')
                .attr('class', 'axis-orb axis-orb-current y-orb')
                .attr('cx', yCurrentPos.x - 25)
                .attr('cy', yCurrentPos.y)
                .attr('r', 12)
                .attr('fill', '#4488ff')
                .attr('stroke', '#fff')
                .attr('stroke-width', 3);
            
            // ===== Z-axis (Dependencies) - Bottom left edge going back =====
            const zAxisGroup = g.append('g').attr('class', 'z-axis-group');
            
            for (let i = 0; i < 4; i++) {
                // Position Z-axis outside cube bounds (cube X goes 0-3, so position at X = -0.5)
                const segStart = project3D(-0.5, -1, Math.max(-0.5, i - 0.5));
                const segEnd = project3D(-0.5, -1, Math.min(3.5, i + 0.5));
                // Offset the Z axis down from cube bottom and left from cube edge
                const offsetY = axisOffset;
                
                // Draw main segment
                zAxisGroup.append('line')
                    .attr('class', 'axis-segment z-axis')
                    .attr('data-value', i)
                    .attr('x1', segStart.x)
                    .attr('y1', segStart.y + offsetY)
                    .attr('x2', segEnd.x)
                    .attr('y2', segEnd.y + offsetY)
                    .attr('stroke', segmentColors[i])
                    .attr('stroke-width', 20)
                    .attr('stroke-linecap', i === 0 || i === 3 ? 'round' : 'butt')
                    .attr('opacity', 0.7)
                    .style('cursor', 'pointer')
                    .on('mouseover', function() {
                        d3.select(this)
                            .attr('stroke-width', 24)
                            .attr('opacity', 1)
                            .style('filter', 'drop-shadow(0 0 10px currentColor)');
                        // Show connecting line to cube
                        const value = parseInt(d3.select(this).attr('data-value'));
                        const cubePoint = project3D(0, -1, value);
                        const axisPoint = project3D(0, -1, value);
                        g.append('line')
                            .attr('class', 'connecting-line')
                            .attr('x1', axisPoint.x)
                            .attr('y1', axisPoint.y + offsetY)
                            .attr('x2', cubePoint.x)
                            .attr('y2', cubePoint.y)
                            .attr('stroke', segmentColors[i])
                            .attr('stroke-width', 2)
                            .attr('stroke-dasharray', '3,3')
                            .attr('opacity', 0.5);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .attr('stroke-width', 20)
                            .attr('opacity', 0.7)
                            .style('filter', null);
                        g.selectAll('.connecting-line').remove();
                    })
                    .on('click', function() {
                        const value = parseInt(d3.select(this).attr('data-value'));
                        updateAxisValue('dependencies', value);
                    });
                
                // Position tick marks
                const tickPos = project3D(-0.5, -1, i);
                const perpX = 8;
                const perpY = -8;
                g.append('line')
                    .attr('class', 'axis-tick')
                    .attr('x1', tickPos.x - perpX)
                    .attr('y1', tickPos.y + offsetY - perpY)
                    .attr('x2', tickPos.x + perpX)
                    .attr('y2', tickPos.y + offsetY + perpY)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 3);
                
                // Position labels
                g.append('text')
                    .attr('class', 'axis-tick-label')
                    .attr('x', tickPos.x + 15)
                    .attr('y', tickPos.y + offsetY - 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', 'bold')
                    .style('fill', '#666')
                    .text(i);
            }
            
            // Z axis emoji endpoints
            const zStart = project3D(-0.5, -1, -0.5);
            const zEnd = project3D(-0.5, -1, 3.5);
            const offsetY = axisOffset;
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', zStart.x - 15)
                .attr('y', zStart.y + offsetY - 10)
                .attr('text-anchor', 'end')
                .style('font-size', '24px')
                .text('🌀');
            
            g.append('text')
                .attr('class', 'axis-emoji')
                .attr('x', zEnd.x + 15)
                .attr('y', zEnd.y + offsetY + 10)
                .attr('text-anchor', 'start')
                .style('font-size', '24px')
                .text('🎀');
            
            // Z axis current position orb with pulsing animation
            const zCurrentPos = project3D(-0.5, -1, currentDeps);
            g.append('circle')
                .attr('class', 'axis-orb axis-orb-current z-orb')
                .attr('cx', zCurrentPos.x)
                .attr('cy', zCurrentPos.y + axisOffset)
                .attr('r', 12)
                .attr('fill', '#4488ff')
                .attr('stroke', '#fff')
                .attr('stroke-width', 3);
        }
        
        function showStateDescription(vertex) {
            const desc = vertex.description;
            const descDiv = d3.select('#state-description');
            
            // Get all three emoji for complete state
            const signalEmoji = signalEmojis[vertex.signal];
            const depEmoji = dependencyEmojis[vertex.dependencies];
            const errorEmoji = errorEmojis[vertex.error];
            const fullEmoji = `${signalEmoji}${depEmoji}${errorEmoji}`;
            
            let html = `
                <h3><span class="emoji-large">${fullEmoji}</span> ${desc.title}</h3>
                <p><strong>Coordinates:</strong> Signal=${vertex.signal} (${signalEmoji}), Dependencies=${vertex.dependencies} (${depEmoji}), Error=${vertex.error} (${errorEmoji})</p>
                <p>${desc.description}</p>
            `;
            
            if (desc.code) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>What this feels like in code:</strong>
                        <div class="code-example">
                            <div class="code-lang">${desc.code.lang}</div>
${desc.code.code}
                        </div>
                    </div>
                `;
            }
            
            html += `
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Height represents phenomenological intensity - how "alive" this state feels.
                </p>
            `;
            
            descDiv.html(html);
            
            // Add a subtle animation
            descDiv.style('transform', 'scale(0.95)')
                .transition()
                .duration(200)
                .style('transform', 'scale(1)');
        }
        
        function drawCoordinateGuides(signal, dependencies, error) {
            // Remove previous guides
            g.selectAll('.coord-guide').remove();
            
            // Draw vertical guide lines from base to selected point
            const errorOffset = error * 0.5;
            const height = primarySurface(signal, dependencies) - errorOffset;
            
            // Vertical line from bottom
            const bottomPoint = project3D(signal, -1, dependencies);
            const topPoint = project3D(signal, height, dependencies);
            
            g.append('line')
                .attr('class', 'coord-guide')
                .attr('x1', bottomPoint.x)
                .attr('y1', bottomPoint.y)
                .attr('x2', topPoint.x)
                .attr('y2', topPoint.y)
                .attr('stroke', '#ff0066')
                .attr('stroke-width', 3)
                .attr('stroke-opacity', 0.6)
                .attr('stroke-dasharray', '5,5');
            
            // Grid lines on base plane
            // Signal line
            for(let z = 0; z <= 3; z += 0.5) {
                const p1 = project3D(signal, -1, z);
                const alpha = Math.abs(z - dependencies) < 0.1 ? 1 : 0.3;
                g.append('line')
                    .attr('class', 'coord-guide')
                    .attr('x1', p1.x - 10)
                    .attr('y1', p1.y)
                    .attr('x2', p1.x + 10)
                    .attr('y2', p1.y)
                    .attr('stroke', '#ff0066')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', alpha);
            }
            
            // Dependencies line
            for(let x = 0; x <= 3; x += 0.5) {
                const p1 = project3D(x, -1, dependencies);
                const alpha = Math.abs(x - signal) < 0.1 ? 1 : 0.3;
                g.append('line')
                    .attr('class', 'coord-guide')
                    .attr('x1', p1.x - 10)
                    .attr('y1', p1.y)
                    .attr('x2', p1.x + 10)
                    .attr('y2', p1.y)
                    .attr('stroke', '#ff0066')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', alpha);
            }
            
            // Draw coordinate planes intersection
            const planePoints = [
                project3D(0, height, dependencies),
                project3D(3, height, dependencies),
                project3D(signal, height, 0),
                project3D(signal, height, 3)
            ];
            
            g.append('line')
                .attr('class', 'coord-guide')
                .attr('x1', planePoints[0].x)
                .attr('y1', planePoints[0].y)
                .attr('x2', planePoints[1].x)
                .attr('y2', planePoints[1].y)
                .attr('stroke', '#ff0066')
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.4)
                .attr('stroke-dasharray', '3,3');
                
            g.append('line')
                .attr('class', 'coord-guide')
                .attr('x1', planePoints[2].x)
                .attr('y1', planePoints[2].y)
                .attr('x2', planePoints[3].x)
                .attr('y2', planePoints[3].y)
                .attr('stroke', '#ff0066')
                .attr('stroke-width', 2)
                .attr('stroke-opacity', 0.4)
                .attr('stroke-dasharray', '3,3');
        }
        
        function updateSelectedState() {
            // Check if DOM elements exist before trying to access them
            const signalSlider = d3.select('#signal-slider');
            const dependencySlider = d3.select('#dependency-slider');
            const errorSlider = d3.select('#error-slider');
            
            if (signalSlider.empty() || dependencySlider.empty() || errorSlider.empty()) {
                // DOM not ready yet, skip update
                return;
            }
            
            const signal = parseInt(signalSlider.property('value'));
            const dependencies = parseInt(dependencySlider.property('value'));
            const error = parseInt(errorSlider.property('value'));
            
            // Update emoji displays
            d3.select('#signal-value').text(signalEmojis[signal]);
            d3.select('#dependency-value').text(dependencyEmojis[dependencies]);
            d3.select('#error-value').text(errorEmojis[error]);
            
            // Calculate position for selected point
            const errorOffset = error * 0.5;
            const height = primarySurface(signal, dependencies) - errorOffset;
            const projected = project3D(signal, height, dependencies);
            
            // Remove old indicator
            g.selectAll('#selected-indicator').remove();
            g.selectAll('#coordinate-label').remove();
            
            // Add new indicator
            g.append('circle')
                .attr('id', 'selected-indicator')
                .attr('cx', projected.x)
                .attr('cy', projected.y)
                .attr('r', 8)
                .attr('fill', 'none')
                .attr('stroke', '#ff0066')
                .attr('stroke-width', 3)
                .attr('stroke-dasharray', '5,5');
            
            // Add coordinate label
            const labelGroup = g.append('g')
                .attr('id', 'coordinate-label')
                .attr('transform', `translate(${projected.x}, ${projected.y - 25})`);
                
            labelGroup.append('rect')
                .attr('rx', 4)
                .attr('ry', 4)
                .attr('fill', 'white')
                .attr('stroke', '#ff0066')
                .attr('stroke-width', 1);
                
            labelGroup.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', 0)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#ff0066')
                .text(`(${signal}, ${dependencies}, ${error})`);
            
            // Draw coordinate guide lines
            drawCoordinateGuides(signal, dependencies, error);
            
            // Update background rect after positioning
            setTimeout(() => {
                const textNode = labelGroup.select('text').node();
                if (textNode) {
                    const bbox = textNode.getBBox();
                    labelGroup.select('rect')
                        .attr('x', bbox.x - 8)
                        .attr('y', bbox.y - 4)
                        .attr('width', bbox.width + 16)
                        .attr('height', bbox.height + 8);
                }
            }, 50);
            
            // Update the description
            const description = getStateDescription(signal, dependencies, error);
            const signalEmoji = signalEmojis[signal];
            const depEmoji = dependencyEmojis[dependencies];
            const errorEmoji = errorEmojis[error];
            const fullEmoji = `${signalEmoji}${depEmoji}${errorEmoji}`;
            
            let html = `
                <h3 style="margin-top: 0;"><span class="emoji-large">${fullEmoji}</span> ${description.title}</h3>
                <p><strong>State:</strong> (${signal}, ${dependencies}, ${error})</p>
                <p>${description.description}</p>
            `;
            
            if (description.code) {
                html += `
                    <div style="margin-top: 15px;">
                        <strong>What this feels like in code:</strong>
                        <div class="code-example">
                            <div class="code-lang">${description.code.lang}</div>
${description.code.code}
                        </div>
                    </div>
                `;
            }
            
            html += `
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Position shows phenomenological intensity - height indicates how cognitively "alive" this state feels.
                    ${height > 2 ? "This is a high-energy state." : height < -1 ? "This is a low-energy, difficult state." : "This is a moderate state."}
                </p>
            `;
            
            d3.select('#state-details').html(html);
        }
        
        // Update axis value function
        function updateAxisValue(axis, value) {
            if (axis === 'signal') currentState.signal = value;
            else if (axis === 'dependencies') currentState.dependencies = value;
            else if (axis === 'error') currentState.error = value;
            
            updateStateDisplay();
            drawAxes(); // Redraw axes to update orb positions
            drawProjections(); // Update projection lines
            updatePresetButtons(); // Update active preset button
        }
        
        // Set preset with visual feedback
        window.setPreset = function(presetName, signal, deps, error) {
            currentState.signal = signal;
            currentState.dependencies = deps;
            currentState.error = error;
            
            updateStateDisplay();
            drawAxes();
            drawProjections();
            
            // Update active button
            d3.selectAll('.preset-btn').classed('active', false);
            d3.select(`#preset-${presetName}`).classed('active', true);
        }
        
        // Update preset button active states based on current state
        function updatePresetButtons() {
            const presets = [
                { id: 'preset-peak', signal: 3, deps: 3, error: 3 },
                { id: 'preset-chaos', signal: 0, deps: 0, error: 0 },
                { id: 'preset-balance', signal: 2, deps: 2, error: 2 },
                { id: 'preset-sweet', signal: 2, deps: 1, error: 2 }
            ];
            
            d3.selectAll('.preset-btn').classed('active', false);
            
            // Check if current state matches any preset
            presets.forEach(preset => {
                if (currentState.signal === preset.signal && 
                    currentState.dependencies === preset.deps && 
                    currentState.error === preset.error) {
                    d3.select(`#${preset.id}`).classed('active', true);
                }
            });
        }
        
        // Update state display
        function updateStateDisplay() {
            const desc = getStateDescription(currentState.signal, currentState.dependencies, currentState.error);
            
            d3.select('#state-emoji').text(desc.emoji);
            d3.select('#state-title').text(desc.title);
            
            // Color-coded coordinates
            d3.select('#state-coords').html(`
                <span class="coord-signal">Signal: ${currentState.signal}</span>, 
                <span class="coord-deps">Dependencies: ${currentState.dependencies}</span>, 
                <span class="coord-error">Error: ${currentState.error}</span>
            `);
            
            d3.select('#state-description').text(desc.description);
            
            // Update phenomenology data if available
            if (desc.phenomenology) {
                d3.select('#state-phenomenology').text(desc.phenomenology);
                d3.select('#phenomenology-toggle').style('display', 'block');
            } else {
                d3.select('#phenomenology-toggle').style('display', 'none');
            }
            
            // Reset phenomenology section visibility
            d3.select('#phenomenology-section').style('display', 'none');
            d3.select('#phenomenology-toggle').text('Show phenomenology →');
        }
        
        // Show code example function
        window.showCodeExample = function() {
            const desc = getStateDescription(currentState.signal, currentState.dependencies, currentState.error);
            if (!desc.code) {
                alert('No code example available for this state.');
                return;
            }
            
            // Create modal overlay
            const modal = d3.select('body').append('div')
                .style('position', 'fixed')
                .style('top', '0')
                .style('left', '0')
                .style('width', '100%')
                .style('height', '100%')
                .style('background', 'rgba(0, 0, 0, 0.8)')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('z-index', '1000')
                .on('click', function() { modal.remove(); });
            
            // Create modal content
            const content = modal.append('div')
                .style('background', '#1e1e1e')
                .style('border-radius', '12px')
                .style('padding', '24px')
                .style('max-width', '800px')
                .style('max-height', '80vh')
                .style('overflow', 'auto')
                .style('box-shadow', '0 20px 60px rgba(0, 0, 0, 0.5)')
                .on('click', function(event) { event.stopPropagation(); });
            
            // Generate unique ID for copy button
            const copyBtnId = 'copy-btn-' + Date.now();
            
            // Add header with copy button
            content.append('div')
                .style('display', 'flex')
                .style('justify-content', 'space-between')
                .style('align-items', 'center')
                .style('margin-bottom', '20px')
                .html(`
                    <div style="color: #e0e0e0; flex: 1;">
                        <h3 style="margin: 0; font-size: 20px;">${desc.emoji} ${desc.title}</h3>
                        <p style="margin: 4px 0 0 0; font-size: 14px; color: #999;">What this state feels like in code:</p>
                    </div>
                    <div style="display: flex; gap: 12px; align-items: center;">
                        <button id="${copyBtnId}" 
                                style="background: #4488ff; border: none; color: white; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            Copy Code
                        </button>
                        <button onclick="this.closest('div').parentElement.parentElement.remove()" 
                                style="background: none; border: none; color: #999; font-size: 24px; cursor: pointer; line-height: 1;">×</button>
                    </div>
                `);
            
            // Add descriptions
            if (desc.description || desc.phenomenology) {
                const descContainer = content.append('div')
                    .style('margin-bottom', '20px')
                    .style('padding', '16px')
                    .style('background', 'rgba(255, 255, 255, 0.05)')
                    .style('border-radius', '8px');
                
                if (desc.description) {
                    descContainer.append('p')
                        .style('margin', '0 0 12px 0')
                        .style('color', '#e0e0e0')
                        .style('font-size', '14px')
                        .style('line-height', '1.6')
                        .html(`<strong>For Humans:</strong> ${desc.description}`);
                }
                
                if (desc.phenomenology) {
                    descContainer.append('p')
                        .style('margin', '0')
                        .style('color', '#b0b0b0')
                        .style('font-size', '13px')
                        .style('font-style', 'italic')
                        .style('line-height', '1.6')
                        .html(`<strong>Phenomenology:</strong> ${desc.phenomenology}`);
                }
            }
            
            // Map language names for Prism
            const languageMap = {
                'javascript': 'javascript',
                'JavaScript': 'javascript',
                'JavaScript (Legacy)': 'javascript',
                'python': 'python',
                'Python': 'python',
                'haskell': 'haskell',
                'Haskell': 'haskell',
                'rust': 'rust',
                'Rust': 'rust',
                'typescript': 'typescript',
                'TypeScript': 'typescript',
                'c': 'c',
                'C': 'c',
                'cpp': 'cpp',
                'c++': 'cpp',
                'C++': 'cpp',
                'java': 'java',
                'Java': 'java',
                'go': 'go',
                'Go': 'go',
                'ruby': 'ruby',
                'Ruby': 'ruby',
                'php': 'php',
                'PHP': 'php',
                'swift': 'swift',
                'Swift': 'swift',
                'kotlin': 'kotlin',
                'Kotlin': 'kotlin',
                'scala': 'scala',
                'Scala': 'scala',
                'sql': 'sql',
                'SQL': 'sql'
            };
            
            const prismLang = languageMap[desc.code.lang] || 'plaintext';
            
            // Add code with syntax highlighting
            const codeContainer = content.append('div')
                .style('position', 'relative');
            
            codeContainer.append('div')
                .style('background', 'rgba(68, 136, 255, 0.1)')
                .style('padding', '8px 16px')
                .style('border-radius', '8px 8px 0 0')
                .style('font-size', '12px')
                .style('color', '#4488ff')
                .style('font-weight', '600')
                .text(desc.code.lang);
            
            const pre = codeContainer.append('pre')
                .style('margin', '0')
                .style('background', '#2d2d2d')
                .style('padding', '16px')
                .style('border-radius', '0 0 8px 8px')
                .style('overflow-x', 'auto');
            
            const code = pre.append('code')
                .attr('class', `language-${prismLang}`)
                .text(desc.code.code);
            
            // Apply syntax highlighting
            Prism.highlightElement(code.node());
            
            // Add copy functionality
            d3.select(`#${copyBtnId}`).on('click', function() {
                navigator.clipboard.writeText(desc.code.code).then(() => {
                    const btn = d3.select(this);
                    const originalText = btn.text();
                    btn.text('Copied!');
                    setTimeout(() => btn.text(originalText), 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    alert('Failed to copy code to clipboard');
                });
            });
        };
        
        // Toggle phenomenology section
        window.togglePhenomenology = function() {
            const section = d3.select('#phenomenology-section');
            const toggle = d3.select('#phenomenology-toggle');
            const isVisible = section.style('display') !== 'none';
            
            if (isVisible) {
                section.style('display', 'none');
                toggle.text('Show phenomenology →');
            } else {
                section.style('display', 'block');
                toggle.text('Hide phenomenology ←');
            }
        };
        
        // Search and filter functionality
        let searchState = {
            query: '',
            filters: {
                transcendent: true,
                good: true,
                functional: true,
                degraded: true,
                struggling: true,
                catastrophic: true
            },
            matchingVertices: new Set()
        };
        
        // Toggle search panel
        window.toggleSearchPanel = function() {
            const panel = d3.select('#search-panel');
            const content = d3.select('#search-content');
            const icon = d3.select('#search-toggle-icon');
            const isCollapsed = panel.classed('collapsed');
            
            if (isCollapsed) {
                panel.classed('collapsed', false);
                content.style('display', 'block');
                icon.text('−');
            } else {
                panel.classed('collapsed', true);
                content.style('display', 'none');
                icon.text('+');
            }
        };
        
        // Clear all filters
        window.clearFilters = function() {
            // Reset checkboxes
            d3.selectAll('.filter-checkbox input').property('checked', true);
            
            // Reset search
            d3.select('#search-input').property('value', '');
            
            // Reset state
            searchState.query = '';
            Object.keys(searchState.filters).forEach(key => {
                searchState.filters[key] = true;
            });
            
            // Update display
            updateSearchResults();
        };
        
        // Calculate state score
        function getStateScore(signal, dependencies, error) {
            return signal + dependencies + error;
        }
        
        // Get state category
        function getStateCategory(score) {
            if (score >= 8) return 'transcendent';
            if (score >= 6) return 'good';
            if (score >= 4) return 'functional';
            if (score >= 2) return 'degraded';
            if (score >= 1) return 'struggling';
            return 'catastrophic';
        }
        
        // Update search results
        function updateSearchResults() {
            searchState.matchingVertices.clear();
            let matchCount = 0;
            
            // Check each possible state
            for (let signal = 0; signal <= 3; signal++) {
                for (let dependencies = 0; dependencies <= 3; dependencies++) {
                    for (let error = 0; error <= 3; error++) {
                        const score = getStateScore(signal, dependencies, error);
                        const category = getStateCategory(score);
                        
                        // Check category filter
                        if (!searchState.filters[category]) continue;
                        
                        // Check search query
                        if (searchState.query) {
                            const desc = getStateDescription(signal, dependencies, error);
                            const searchText = searchState.query.toLowerCase();
                            const matches = 
                                desc.emoji.includes(searchText) ||
                                desc.title.toLowerCase().includes(searchText) ||
                                desc.description.toLowerCase().includes(searchText) ||
                                (desc.phenomenology && desc.phenomenology.toLowerCase().includes(searchText)) ||
                                `${signal}-${dependencies}-${error}`.includes(searchText);
                            
                            if (!matches) continue;
                        }
                        
                        searchState.matchingVertices.add(`${signal}-${dependencies}-${error}`);
                        matchCount++;
                    }
                }
            }
            
            // Update count display
            d3.select('#search-count').text(matchCount);
            
            // Update vertex highlighting
            updateVertexHighlighting();
        }
        
        // Update vertex highlighting based on search
        function updateVertexHighlighting() {
            d3.selectAll('.vertex-point').each(function(d) {
                const vertex = d3.select(this);
                const key = `${d.signal}-${d.dependencies}-${d.error}`;
                const isMatch = searchState.matchingVertices.size === 0 || searchState.matchingVertices.has(key);
                
                vertex.classed('vertex-highlight', isMatch && searchState.matchingVertices.size > 0 && searchState.matchingVertices.size < 64);
                vertex.classed('vertex-dimmed', !isMatch && searchState.matchingVertices.size > 0);
            });
        }
        
        // Initialize search event listeners
        function initializeSearch() {
            // Search input with debouncing
            let searchTimeout;
            d3.select('#search-input').on('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    searchState.query = this.value;
                    updateSearchResults();
                }, 300);
            });
            
            // Filter checkboxes
            d3.selectAll('.filter-checkbox input').on('change', function() {
                const category = this.id.replace('filter-', '');
                searchState.filters[category] = this.checked;
                updateSearchResults();
            });
            
            // Keyboard shortcut for search (Ctrl+F or Cmd+F)
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    e.preventDefault();
                    d3.select('#search-panel').classed('collapsed', false);
                    d3.select('#search-content').style('display', 'block');
                    d3.select('#search-toggle-icon').text('−');
                    d3.select('#search-input').node().focus();
                }
            });
        }
        
        // Fixed view - no reset needed
        
        // Fixed isometric view - no camera controls
        
        // Initialize constellation before first draw
        initializeConstellation();
        
        // Initial draw
        drawSurfaces();
        
        // Initialize state display
        updateStateDisplay();
        
        // Initialize preset buttons
        updatePresetButtons();
        
        // Initialize search functionality
        initializeSearch();
        
        // Subtle parallax effect on mouse movement
        let parallaxEnabled = true;
        document.addEventListener('mousemove', function(e) {
            if (!parallaxEnabled) return;
            
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const deltaX = (e.clientX - centerX) / centerX;
            const deltaY = (e.clientY - centerY) / centerY;
            
            // Subtle shift for surfaces (very minimal)
            d3.selectAll('.surface-path')
                .style('transform', `translate(${deltaX * 0.5}px, ${deltaY * 0.5}px)`);
            
            // Slightly more movement for UI elements
            d3.selectAll('.state-card, .info-panel, .legend')
                .style('transform', `translate(${deltaX * 1}px, ${deltaY * 1}px)`);
        });
        
        // Disable parallax on small screens for performance
        if (window.innerWidth < 768) {
            parallaxEnabled = false;
        }
        
        // Initialize constellation mini-map
        function initializeConstellation() {
            const constellationSvg = d3.select('#constellation-svg');
            const cWidth = 200;
            const cHeight = 150;
            const padding = 20;
            
            // Create 3D to 2D minimap projection
            const miniScale = (cWidth - 2 * padding) / 8; // Scale for 0-3 range on each axis
            
            // Draw grid lines
            const gridGroup = constellationSvg.append('g')
                .attr('class', 'constellation-grid');
            
            // X-axis grid lines
            for (let i = 0; i <= 3; i++) {
                const x = padding + (i / 3) * (cWidth - 2 * padding);
                gridGroup.append('line')
                    .attr('x1', x)
                    .attr('y1', padding)
                    .attr('x2', x)
                    .attr('y2', cHeight - padding)
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 0.5);
            }
            
            // Y-axis grid lines  
            for (let i = 0; i <= 3; i++) {
                const y = padding + (i / 3) * (cHeight - 2 * padding);
                gridGroup.append('line')
                    .attr('x1', padding)
                    .attr('y1', y)
                    .attr('x2', cWidth - padding)
                    .attr('y2', y)
                    .attr('stroke', '#ddd')
                    .attr('stroke-width', 0.5);
            }
            
            // Create groups for different layers
            constellationSvg.append('g').attr('class', 'constellation-heatmap');
            constellationSvg.append('g').attr('class', 'constellation-trails');
            constellationSvg.append('g').attr('class', 'constellation-points');
        }
        
        // Update constellation mini-map
        function updateConstellation() {
            const constellationSvg = d3.select('#constellation-svg');
            const cWidth = 200;
            const cHeight = 150;
            const padding = 20;
            
            // Add current state to history
            const stateKey = `${currentState.signal}-${currentState.dependencies}-${currentState.error}`;
            stateHistory.push({...currentState, timestamp: Date.now()});
            
            // Update frequency count
            stateFrequency[stateKey] = (stateFrequency[stateKey] || 0) + 1;
            
            // Limit history length
            if (stateHistory.length > stateHistoryMax) {
                stateHistory.shift();
            }
            
            // Project state to 2D minimap coordinates
            // Use signal as X, dependencies as Y, and show error as color/size
            function projectToMinimap(state) {
                const x = padding + (state.signal / 3) * (cWidth - 2 * padding);
                const y = cHeight - padding - (state.dependencies / 3) * (cHeight - 2 * padding);
                return {x, y, error: state.error};
            }
            
            // Update heat map for frequently visited states
            const heatmapGroup = constellationSvg.select('.constellation-heatmap');
            heatmapGroup.selectAll('*').remove();
            
            Object.entries(stateFrequency).forEach(([key, count]) => {
                if (count > 2) { // Only show states visited more than twice
                    const [signal, deps, error] = key.split('-').map(Number);
                    const pos = projectToMinimap({signal, dependencies: deps, error});
                    
                    heatmapGroup.append('circle')
                        .attr('class', 'constellation-heat')
                        .attr('cx', pos.x)
                        .attr('cy', pos.y)
                        .attr('r', Math.min(20, 5 + count * 2))
                        .attr('fill', '#ff6b6b')
                        .attr('opacity', Math.min(0.3, count * 0.05));
                }
            });
            
            // Draw trails between consecutive states
            const trailsGroup = constellationSvg.select('.constellation-trails');
            trailsGroup.selectAll('*').remove();
            
            if (stateHistory.length > 1) {
                const lineGenerator = d3.line()
                    .x(d => projectToMinimap(d).x)
                    .y(d => projectToMinimap(d).y)
                    .curve(d3.curveCardinal.tension(0.5));
                
                // Draw fading trail
                for (let i = 1; i < stateHistory.length; i++) {
                    const segment = [stateHistory[i-1], stateHistory[i]];
                    const age = (Date.now() - stateHistory[i].timestamp) / 10000; // Age in 10s of seconds
                    const opacity = Math.max(0.1, 0.6 * (1 - age));
                    
                    trailsGroup.append('path')
                        .datum(segment)
                        .attr('class', 'constellation-trail')
                        .attr('d', lineGenerator)
                        .attr('opacity', opacity);
                }
            }
            
            // Draw recent state points
            const pointsGroup = constellationSvg.select('.constellation-points');
            pointsGroup.selectAll('*').remove();
            
            // Show last 5 states
            const recentStates = stateHistory.slice(-5);
            recentStates.forEach((state, i) => {
                const pos = projectToMinimap(state);
                const isCurrentState = i === recentStates.length - 1;
                
                pointsGroup.append('circle')
                    .attr('class', isCurrentState ? 'constellation-current' : 'constellation-point')
                    .attr('cx', pos.x)
                    .attr('cy', pos.y)
                    .attr('r', isCurrentState ? 6 : 3)
                    .attr('opacity', isCurrentState ? 1 : 0.5 + (i / recentStates.length) * 0.5);
            });
            
            // Add axis labels
            if (!constellationSvg.select('.axis-labels').node()) {
                const labelsGroup = constellationSvg.append('g').attr('class', 'axis-labels');
                
                // X-axis label
                labelsGroup.append('text')
                    .attr('x', cWidth / 2)
                    .attr('y', cHeight - 5)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '9px')
                    .style('fill', '#666')
                    .text('Signal →');
                
                // Y-axis label
                labelsGroup.append('text')
                    .attr('x', 10)
                    .attr('y', cHeight / 2)
                    .attr('text-anchor', 'middle')
                    .attr('transform', `rotate(-90, 10, ${cHeight / 2})`)
                    .style('font-size', '9px')
                    .style('fill', '#666')
                    .text('Dependencies →');
            }
        }
        
        // Draw living annotations at extreme states
        function drawLivingAnnotations() {
            // Remove old annotations
            g.selectAll('.living-annotation').remove();
            
            const annotations = [
                {
                    position: [0, 0, 0],
                    label: "Crisis Point",
                    color: "#dc2626",
                    pulseRadius: [20, 25],
                    description: "System breakdown"
                },
                {
                    position: [3, 3, 3],
                    label: "Peak Performance",
                    color: "#10b981",
                    pulseRadius: [20, 25],
                    description: "Transcendent flow"
                },
                {
                    position: [2, 1, 2],
                    label: "Sweet Spot",
                    color: "#9333ea",
                    pulseRadius: [15, 20],
                    description: "Optimal balance"
                }
            ];
            
            annotations.forEach((annotation, i) => {
                const pos3D = project3D(
                    annotation.position[0],
                    primarySurface(annotation.position[0], annotation.position[1]) + 0.5,
                    annotation.position[1]
                );
                
                const annotationGroup = g.append('g')
                    .attr('class', 'living-annotation')
                    .attr('transform', `translate(${pos3D.x}, ${pos3D.y})`);
                
                // Pulsing circle
                const pulseCircle = annotationGroup.append('circle')
                    .attr('r', annotation.pulseRadius[0])
                    .attr('fill', 'none')
                    .attr('stroke', annotation.color)
                    .attr('stroke-width', 2)
                    .attr('opacity', 0.3);
                
                // Animate pulse
                pulseCircle
                    .append('animate')
                    .attr('attributeName', 'r')
                    .attr('values', `${annotation.pulseRadius[0]};${annotation.pulseRadius[1]};${annotation.pulseRadius[0]}`)
                    .attr('dur', '3s')
                    .attr('repeatCount', 'indefinite');
                
                pulseCircle
                    .append('animate')
                    .attr('attributeName', 'opacity')
                    .attr('values', '0.3;0.1;0.3')
                    .attr('dur', '3s')
                    .attr('repeatCount', 'indefinite');
                
                // Center dot
                annotationGroup.append('circle')
                    .attr('r', 4)
                    .attr('fill', annotation.color)
                    .attr('stroke', 'white')
                    .attr('stroke-width', 2);
                
                // Label background
                const labelBg = annotationGroup.append('rect')
                    .attr('x', -50)
                    .attr('y', -35)
                    .attr('width', 100)
                    .attr('height', 22)
                    .attr('rx', 11)
                    .attr('fill', 'rgba(255, 255, 255, 0.9)')
                    .attr('stroke', annotation.color)
                    .attr('stroke-width', 1)
                    .style('opacity', 0);
                
                // Label text
                const labelText = annotationGroup.append('text')
                    .attr('y', -20)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', annotation.color)
                    .style('opacity', 0)
                    .text(annotation.label);
                
                // Show label on hover
                annotationGroup
                    .on('mouseover', function() {
                        labelBg.transition().duration(200).style('opacity', 1);
                        labelText.transition().duration(200).style('opacity', 1);
                    })
                    .on('mouseout', function() {
                        labelBg.transition().duration(400).style('opacity', 0);
                        labelText.transition().duration(400).style('opacity', 0);
                    });
            });
        }
        
        // Draw phenomenological territories
        function drawPhenomenologicalTerritories() {
            // Remove old territories
            g.selectAll('.territory-region').remove();
            
            const territories = [
                {
                    bounds: [[2, 2, 2], [3, 3, 3]], 
                    name: "Flow States", 
                    color: "rgba(16, 185, 129, 0.08)",
                    hoverColor: "rgba(16, 185, 129, 0.15)"
                },
                {
                    bounds: [[0, 0, 0], [1, 1, 1]], 
                    name: "Struggle Zone", 
                    color: "rgba(220, 38, 38, 0.08)",
                    hoverColor: "rgba(220, 38, 38, 0.15)"
                },
                {
                    bounds: [[1, 2, 2], [2, 3, 3]], 
                    name: "Sweet Spots", 
                    color: "rgba(147, 51, 234, 0.08)",
                    hoverColor: "rgba(147, 51, 234, 0.15)"
                },
                {
                    bounds: [[2, 0, 1], [3, 1, 2]], 
                    name: "Clarity Cascade", 
                    color: "rgba(59, 130, 246, 0.08)",
                    hoverColor: "rgba(59, 130, 246, 0.15)"
                }
            ];
            
            territories.forEach(territory => {
                // Calculate center of territory
                const centerX = (territory.bounds[0][0] + territory.bounds[1][0]) / 2;
                const centerY = -0.5; // Place just below the surface
                const centerZ = (territory.bounds[0][2] + territory.bounds[1][2]) / 2;
                const center3D = project3D(centerX, centerY, centerZ);
                
                // Create invisible hit area for the territory
                const width = (territory.bounds[1][0] - territory.bounds[0][0] + 1) * scale * 0.7;
                const height = (territory.bounds[1][2] - territory.bounds[0][2] + 1) * scale * 0.7;
                
                const territoryGroup = g.append('g')
                    .attr('class', 'territory-region')
                    .style('opacity', 0);
                
                // Add subtle background rect
                territoryGroup.append('rect')
                    .attr('x', center3D.x - width/2)
                    .attr('y', center3D.y - height/2)
                    .attr('width', width)
                    .attr('height', height)
                    .attr('rx', 10)
                    .attr('fill', territory.color)
                    .attr('stroke', 'none')
                    .style('mix-blend-mode', 'multiply');
                
                // Add territory label
                territoryGroup.append('text')
                    .attr('x', center3D.x)
                    .attr('y', center3D.y)
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .style('font-size', '14px')
                    .style('font-weight', '600')
                    .style('fill', territory.color.replace('0.08', '0.8'))
                    .style('letter-spacing', '1px')
                    .style('text-transform', 'uppercase')
                    .text(territory.name);
                
                // Add hover interactions
                territoryGroup
                    .on('mouseover', function() {
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .style('opacity', 1);
                        
                        d3.select(this).select('rect')
                            .attr('fill', territory.hoverColor);
                    })
                    .on('mouseout', function() {
                        d3.select(this)
                            .transition()
                            .duration(400)
                            .style('opacity', 0);
                        
                        d3.select(this).select('rect')
                            .attr('fill', territory.color);
                    });
            });
        }
        
        } catch (error) {
            console.error('Visualization error:', error);
        }
        
        } // End of initializeVisualization function
    </script>
</body>
</html>